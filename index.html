<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë°°ë‹¬ ê²½ë¡œ ìµœì í™” ì‹œë®¬ë ˆì´ì…˜ (TSP Brute Force)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            background: white;
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            text-align: center;
        }
        
        .header h1 {
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            color: #666;
            font-size: 1.2em;
            line-height: 1.6;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .control-panel {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            height: fit-content;
        }
        
        .control-panel h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.5em;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            color: #333;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }
        
        .form-group input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .points-list {
            max-height: 300px;
            overflow-y: auto;
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .point-item {
            background: white;
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .point-label {
            font-weight: bold;
            color: #667eea;
        }
        
        .point-coords {
            color: #666;
            font-family: 'Courier New', monospace;
        }
        
        .depot-badge {
            background: #28a745;
            color: white;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.85em;
        }
        
        .customer-badge {
            background: #667eea;
            color: white;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.85em;
        }
        
        .btn {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 10px;
        }
        
        .btn-primary {
            background: #667eea;
            color: white;
        }
        
        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-success:hover {
            background: #218838;
            transform: translateY(-2px);
        }
        
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        
        .btn-danger:hover {
            background: #c82333;
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .visualization-panel {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        .visualization-panel h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.5em;
        }
        
        canvas {
            width: 100%;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            background: #fafafa;
            cursor: crosshair;
        }
        
        .results-panel {
            background: white;
            border-radius: 20px;
            padding: 30px;
            margin-top: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            display: none;
        }
        
        .results-panel.show {
            display: block;
        }
        
        .result-header {
            color: #28a745;
            font-size: 2em;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .result-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
        }
        
        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
        }
        
        .path-display {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            border-left: 5px solid #667eea;
        }
        
        .path-display h3 {
            color: #667eea;
            margin-bottom: 15px;
        }
        
        .path-sequence {
            font-family: 'Courier New', monospace;
            font-size: 1.3em;
            color: #333;
            line-height: 2;
            word-wrap: break-word;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #667eea;
            font-size: 1.2em;
        }
        
        .controls-row {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .controls-row .btn {
            flex: 1;
        }
        
        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>ğŸšš ë°°ë‹¬ ê²½ë¡œ ìµœì í™” ì‹œë®¬ë ˆì´ì…˜</h1>
            <p>ë¬¼ë¥˜ì„¼í„°(Depot)ì—ì„œ ì¶œë°œí•˜ì—¬ ëª¨ë“  ê³ ê° ì£¼ì†Œë¥¼ ë°©ë¬¸í•œ í›„<br>
            ê°€ì¥ ì§§ì€ ê±°ë¦¬ë¡œ ë‹¤ì‹œ ë¬¼ë¥˜ì„¼í„°ë¡œ ëŒì•„ì˜¤ëŠ” ìµœì  ê²½ë¡œë¥¼ ì°¾ìŠµë‹ˆë‹¤.</p>
        </div>
        
        <!-- Main Content -->
        <div class="main-content">
            <!-- Control Panel -->
            <div class="control-panel">
                <h2>ğŸ“ ì§€ì  ì„¤ì •</h2>
                
                <div class="form-group">
                    <label>ì§€ì  ìˆ˜ (ë¬¼ë¥˜ì„¼í„° í¬í•¨)</label>
                    <input type="number" id="numPoints" min="2" max="10" value="5" placeholder="2-10 ê¶Œì¥">
                </div>
                
                <button class="btn btn-primary" onclick="generateRandomPoints()">ğŸ² ëœë¤ ì§€ì  ìƒì„±</button>
                
                <div class="form-group">
                    <label>ìƒˆ ì§€ì  ì¢Œí‘œ (x, y)</label>
                    <input type="text" id="newPointX" placeholder="X ì¢Œí‘œ (ì˜ˆ: 10)">
                    <input type="text" id="newPointY" placeholder="Y ì¢Œí‘œ (ì˜ˆ: 20)" style="margin-top: 10px;">
                </div>
                
                <button class="btn btn-primary" onclick="addPoint()">â• ì§€ì  ì¶”ê°€</button>
                
                <div class="points-list" id="pointsList">
                    <p style="text-align: center; color: #999;">ì§€ì ì„ ì¶”ê°€í•´ì£¼ì„¸ìš”</p>
                </div>
                
                <button class="btn btn-success" id="solveBtn" onclick="solveTSP()" disabled>ğŸ¯ ìµœì  ê²½ë¡œ ì°¾ê¸°</button>
                <button class="btn btn-danger" onclick="resetAll()">ğŸ”„ ì´ˆê¸°í™”</button>
            </div>
            
            <!-- Visualization Panel -->
            <div class="visualization-panel">
                <h2>ğŸ—ºï¸ ê²½ë¡œ ì‹œê°í™”</h2>
                <canvas id="canvas" width="800" height="600"></canvas>
                
                <div class="controls-row">
                    <button class="btn btn-primary" onclick="toggleAllEdges()" title="ëª¨ë“  ê°€ëŠ¥í•œ ê²½ë¡œ ì„  í‘œì‹œ/ìˆ¨ê¹€">ğŸ”€ ì „ì²´ ì—£ì§€ í† ê¸€</button>
                    <button class="btn btn-primary" onclick="animatePath()" title="ìµœì  ê²½ë¡œë¥¼ ë‹¨ê³„ë³„ë¡œ ê·¸ë¦½ë‹ˆë‹¤ (ë¨¼ì € ê²½ë¡œë¥¼ ì°¾ì•„ì•¼ í•©ë‹ˆë‹¤)">ğŸ¬ ê²½ë¡œ ì• ë‹ˆë©”ì´ì…˜</button>
                </div>
            </div>
        </div>
        
        <!-- Results Panel -->
        <div class="results-panel" id="resultsPanel">
            <h2 class="result-header">âœ… ìµœì  ê²½ë¡œ íƒìƒ‰ ì™„ë£Œ!</h2>
            
            <div class="result-stats">
                <div class="stat-card">
                    <div class="stat-label">ìµœì†Œ ì´ ì´ë™ ê±°ë¦¬</div>
                    <div class="stat-value" id="minDistance">0</div>
                    <div class="stat-label">ê±°ë¦¬ ë‹¨ìœ„</div>
                </div>
                
                <div class="stat-card">
                    <div class="stat-label">íƒìƒ‰í•œ ê²½ë¡œ ìˆ˜</div>
                    <div class="stat-value" id="pathsExplored">0</div>
                    <div class="stat-label">ê°œ</div>
                </div>
                
                <div class="stat-card">
                    <div class="stat-label">ë°©ë¬¸ ì§€ì  ìˆ˜</div>
                    <div class="stat-value" id="totalPoints">0</div>
                    <div class="stat-label">ê°œ</div>
                </div>
            </div>
            
            <div class="path-display">
                <h3>ğŸšš ìµœì  ë°°ë‹¬ ìˆœì„œ</h3>
                <div class="path-sequence" id="pathSequence">-</div>
                <p style="color: #666; margin-top: 10px; font-size: 0.9em;">
                    (P0: ë¬¼ë¥˜ì„¼í„°/Depot, P1~ : ê³ ê° ì£¼ì†Œ/Customer Addresses)
                </p>
            </div>
        </div>
    </div>
    
    <script>
        // Global variables
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let points = {};
        let bestPath = [];
        let minDistance = 0;
        let showAllEdges = false;
        let animating = false;
        let animationProgress = 0;
        
        // Initialize
        function init() {
            drawCanvas();
        }
        
        // Generate random points
        function generateRandomPoints() {
            const numPoints = parseInt(document.getElementById('numPoints').value);
            
            if (numPoints < 2 || numPoints > 10) {
                alert('ì§€ì  ìˆ˜ëŠ” 2-10 ì‚¬ì´ë¡œ ì„¤ì •í•´ì£¼ì„¸ìš”.');
                return;
            }
            
            points = {};
            for (let i = 0; i < numPoints; i++) {
                points[i] = [
                    Math.random() * 80 + 10,
                    Math.random() * 80 + 10
                ];
            }
            
            updatePointsList();
            drawCanvas();
            document.getElementById('solveBtn').disabled = false;
            hideResults();
        }
        
        // Add point manually
        function addPoint() {
            const x = parseFloat(document.getElementById('newPointX').value);
            const y = parseFloat(document.getElementById('newPointY').value);
            
            if (isNaN(x) || isNaN(y)) {
                alert('ì˜¬ë°”ë¥¸ ì¢Œí‘œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }
            
            const newIndex = Object.keys(points).length;
            points[newIndex] = [x, y];
            
            document.getElementById('newPointX').value = '';
            document.getElementById('newPointY').value = '';
            
            updatePointsList();
            drawCanvas();
            
            if (Object.keys(points).length >= 2) {
                document.getElementById('solveBtn').disabled = false;
            }
            
            hideResults();
        }
        
        // Update points list display
        function updatePointsList() {
            const listDiv = document.getElementById('pointsList');
            
            if (Object.keys(points).length === 0) {
                listDiv.innerHTML = '<p style="text-align: center; color: #999;">ì§€ì ì„ ì¶”ê°€í•´ì£¼ì„¸ìš”</p>';
                return;
            }
            
            listDiv.innerHTML = '';
            
            for (let i in points) {
                const item = document.createElement('div');
                item.className = 'point-item';
                
                const info = document.createElement('div');
                const isDepot = i == 0;
                info.innerHTML = `
                    <span class="point-label">P${i}</span>
                    <span class="point-coords">(${points[i][0].toFixed(1)}, ${points[i][1].toFixed(1)})</span>
                `;
                
                const badge = document.createElement('span');
                badge.className = isDepot ? 'depot-badge' : 'customer-badge';
                badge.textContent = isDepot ? 'Depot' : 'Customer';
                
                item.appendChild(info);
                item.appendChild(badge);
                listDiv.appendChild(item);
            }
        }
        
        // Calculate distance between two points
        function calculateDistance(point1, point2) {
            const dx = point2[0] - point1[0];
            const dy = point2[1] - point1[1];
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        // Calculate path length
        function calculatePathLength(path) {
            let total = 0;
            for (let i = 0; i < path.length; i++) {
                const start = points[path[i]];
                const end = points[path[(i + 1) % path.length]];
                total += calculateDistance(start, end);
            }
            return total;
        }
        
        // Generate all permutations
        function* permutations(array) {
            if (array.length <= 1) {
                yield array;
            } else {
                for (let i = 0; i < array.length; i++) {
                    const rest = array.slice(0, i).concat(array.slice(i + 1));
                    for (let perm of permutations(rest)) {
                        yield [array[i]].concat(perm);
                    }
                }
            }
        }
        
        // Solve TSP using brute force
        function solveTSP() {
            if (Object.keys(points).length < 2) {
                alert('ìµœì†Œ 2ê°œì˜ ì§€ì ì´ í•„ìš”í•©ë‹ˆë‹¤.');
                return;
            }
            
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'loading';
            loadingDiv.innerHTML = 'ğŸ”„ ìµœì  ê²½ë¡œ íƒìƒ‰ ì¤‘...';
            document.getElementById('resultsPanel').innerHTML = '';
            document.getElementById('resultsPanel').appendChild(loadingDiv);
            document.getElementById('resultsPanel').classList.add('show');
            
            setTimeout(() => {
                const allIndices = Object.keys(points).map(k => parseInt(k));
                const startPoint = allIndices[0];
                const remainingPoints = allIndices.slice(1);
                
                minDistance = Infinity;
                bestPath = [];
                let pathsExplored = 0;
                
                for (let perm of permutations(remainingPoints)) {
                    const currentPath = [startPoint].concat(perm);
                    const currentLength = calculatePathLength(currentPath);
                    pathsExplored++;
                    
                    if (currentLength < minDistance) {
                        minDistance = currentLength;
                        bestPath = currentPath;
                    }
                }
                
                showResults(pathsExplored);
                drawCanvas();
            }, 100);
        }
        
        // Show results
        function showResults(pathsExplored) {
            const resultsPanel = document.getElementById('resultsPanel');
            resultsPanel.innerHTML = `
                <h2 class="result-header">âœ… ìµœì  ê²½ë¡œ íƒìƒ‰ ì™„ë£Œ!</h2>
                
                <div class="result-stats">
                    <div class="stat-card">
                        <div class="stat-label">ìµœì†Œ ì´ ì´ë™ ê±°ë¦¬</div>
                        <div class="stat-value">${minDistance.toFixed(2)}</div>
                        <div class="stat-label">ê±°ë¦¬ ë‹¨ìœ„</div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-label">íƒìƒ‰í•œ ê²½ë¡œ ìˆ˜</div>
                        <div class="stat-value">${pathsExplored.toLocaleString()}</div>
                        <div class="stat-label">ê°œ</div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-label">ë°©ë¬¸ ì§€ì  ìˆ˜</div>
                        <div class="stat-value">${Object.keys(points).length}</div>
                        <div class="stat-label">ê°œ</div>
                    </div>
                </div>
                
                <div class="path-display">
                    <h3>ğŸšš ìµœì  ë°°ë‹¬ ìˆœì„œ</h3>
                    <div class="path-sequence">${bestPath.map(i => `P${i}`).join(' â†’ ')} â†’ P${bestPath[0]}</div>
                    <p style="color: #666; margin-top: 10px; font-size: 0.9em;">
                        (P0: ë¬¼ë¥˜ì„¼í„°/Depot, P1~: ê³ ê° ì£¼ì†Œ/Customer Addresses)
                    </p>
                </div>
            `;
            resultsPanel.classList.add('show');
            
            // ìë™ìœ¼ë¡œ ì• ë‹ˆë©”ì´ì…˜ ì‹¤í–‰
            setTimeout(() => {
                animatePath();
            }, 500);
        }
        
        // Hide results
        function hideResults() {
            document.getElementById('resultsPanel').classList.remove('show');
            bestPath = [];
            minDistance = 0;
        }
        
        // Draw canvas
        function drawCanvas(progress = 1) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (Object.keys(points).length === 0) {
                ctx.fillStyle = '#999';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ì§€ì ì„ ì¶”ê°€í•˜ê±°ë‚˜ ëœë¤ ìƒì„±í•´ì£¼ì„¸ìš”', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            const padding = 60;
            const scale = Math.min(
                (canvas.width - 2 * padding) / 100,
                (canvas.height - 2 * padding) / 100
            );
            
            function toCanvasX(x) {
                return padding + x * scale;
            }
            
            function toCanvasY(y) {
                return canvas.height - padding - y * scale;
            }
            
            // Draw all edges if enabled
            if (showAllEdges) {
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                ctx.lineWidth = 1;
                const indices = Object.keys(points);
                for (let i = 0; i < indices.length; i++) {
                    for (let j = i + 1; j < indices.length; j++) {
                        const p1 = points[indices[i]];
                        const p2 = points[indices[j]];
                        ctx.beginPath();
                        ctx.moveTo(toCanvasX(p1[0]), toCanvasY(p1[1]));
                        ctx.lineTo(toCanvasX(p2[0]), toCanvasY(p2[1]));
                        ctx.stroke();
                    }
                }
            }
            
            // Draw optimal path with animation
            if (bestPath.length > 0) {
                const totalSegments = bestPath.length;
                const segmentsToShow = Math.floor(progress * totalSegments);
                const partialProgress = (progress * totalSegments) - segmentsToShow;
                
                ctx.strokeStyle = '#dc3545';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                // Draw completed segments
                for (let i = 0; i < segmentsToShow; i++) {
                    const start = points[bestPath[i]];
                    const end = points[bestPath[(i + 1) % bestPath.length]];
                    
                    ctx.beginPath();
                    ctx.moveTo(toCanvasX(start[0]), toCanvasY(start[1]));
                    ctx.lineTo(toCanvasX(end[0]), toCanvasY(end[1]));
                    ctx.stroke();
                    
                    // Draw arrow
                    const angle = Math.atan2(end[1] - start[1], end[0] - start[0]);
                    const midX = (start[0] + end[0]) / 2;
                    const midY = (start[1] + end[1]) / 2;
                    
                    ctx.save();
                    ctx.translate(toCanvasX(midX), toCanvasY(midY));
                    ctx.rotate(-angle);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-15, -8);
                    ctx.lineTo(-15, 8);
                    ctx.closePath();
                    ctx.fillStyle = '#dc3545';
                    ctx.fill();
                    ctx.restore();
                }
                
                // Draw partial segment (animating)
                if (progress < 1 && segmentsToShow < totalSegments) {
                    const i = segmentsToShow;
                    const start = points[bestPath[i]];
                    const end = points[bestPath[(i + 1) % bestPath.length]];
                    
                    const currentX = start[0] + (end[0] - start[0]) * partialProgress;
                    const currentY = start[1] + (end[1] - start[1]) * partialProgress;
                    
                    // Draw partial line
                    ctx.strokeStyle = '#dc3545';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(toCanvasX(start[0]), toCanvasY(start[1]));
                    ctx.lineTo(toCanvasX(currentX), toCanvasY(currentY));
                    ctx.stroke();
                    
                    // Draw animated point at the end
                    ctx.beginPath();
                    ctx.arc(toCanvasX(currentX), toCanvasY(currentY), 8, 0, 2 * Math.PI);
                    ctx.fillStyle = '#FFD700';
                    ctx.fill();
                    ctx.strokeStyle = '#FF6B6B';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            }
            
            // Draw points
            for (let i in points) {
                const p = points[i];
                const x = toCanvasX(p[0]);
                const y = toCanvasY(p[1]);
                const isDepot = i == 0;
                
                // Shadow
                ctx.beginPath();
                ctx.arc(x + 3, y + 3, 22, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fill();
                
                // Circle
                ctx.beginPath();
                ctx.arc(x, y, 20, 0, 2 * Math.PI);
                ctx.fillStyle = isDepot ? '#28a745' : '#667eea';
                ctx.fill();
                ctx.strokeStyle = isDepot ? '#1e7e34' : '#5568d3';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Label
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(i, x, y);
                
                // Depot star
                if (isDepot) {
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 24px Arial';
                    ctx.fillText('â˜…', x, y - 35);
                }
                
                // Visit order
                if (bestPath.length > 0) {
                    const visitOrder = bestPath.indexOf(parseInt(i));
                    if (visitOrder !== -1) {
                        ctx.fillStyle = '#333';
                        ctx.font = 'bold 14px Arial';
                        ctx.fillText(`[${visitOrder}]`, x + 30, y - 25);
                    }
                }
            }
            
            // Draw progress indicator during animation
            if (progress < 1 && bestPath.length > 0) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(10, 10, 200, 40);
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.strokeRect(10, 10, 200, 40);
                
                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`ì• ë‹ˆë©”ì´ì…˜ ì§„í–‰: ${Math.floor(progress * 100)}%`, 20, 35);
            }
        }
        
        // Toggle all edges
        function toggleAllEdges() {
            showAllEdges = !showAllEdges;
            drawCanvas(animationProgress);
        }
        
        // Animate path
        function animatePath() {
            if (bestPath.length === 0) {
                alert('âŒ ë¨¼ì € "ìµœì  ê²½ë¡œ ì°¾ê¸°" ë²„íŠ¼ì„ ëˆŒëŸ¬ ê²½ë¡œë¥¼ ê³„ì‚°í•´ì£¼ì„¸ìš”!');
                return;
            }
            
            if (animating) {
                alert('â¸ï¸ ì• ë‹ˆë©”ì´ì…˜ì´ ì´ë¯¸ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤.');
                return;
            }
            
            animating = true;
            animationProgress = 0;
            
            // Show notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #28a745;
                color: white;
                padding: 15px 25px;
                border-radius: 10px;
                box-shadow: 0 5px 15px rgba(0,0,0,0.3);
                z-index: 1000;
                font-weight: bold;
            `;
            notification.textContent = 'ğŸ¬ ê²½ë¡œ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘!';
            document.body.appendChild(notification);
            
            setTimeout(() => notification.remove(), 2000);
            
            function animate() {
                animationProgress += 0.015; // ì¡°ê¸ˆ ë” ì²œì²œíˆ
                if (animationProgress >= 1) {
                    animationProgress = 1;
                    animating = false;
                    
                    // Show completion notification
                    const doneNotif = document.createElement('div');
                    doneNotif.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: #667eea;
                        color: white;
                        padding: 15px 25px;
                        border-radius: 10px;
                        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
                        z-index: 1000;
                        font-weight: bold;
                    `;
                    doneNotif.textContent = 'âœ… ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ!';
                    document.body.appendChild(doneNotif);
                    setTimeout(() => doneNotif.remove(), 2000);
                }
                drawCanvas(animationProgress);
                if (animating) requestAnimationFrame(animate);
            }
            animate();
        }
        
        // Reset all
        function resetAll() {
            if (confirm('ëª¨ë“  ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                points = {};
                bestPath = [];
                minDistance = 0;
                showAllEdges = false;
                animating = false;
                animationProgress = 0;
                
                updatePointsList();
                drawCanvas();
                hideResults();
                document.getElementById('solveBtn').disabled = true;
            }
        }
        
        // Initialize on load
        window.addEventListener('load', init);
    </script>
</body>
</html>
